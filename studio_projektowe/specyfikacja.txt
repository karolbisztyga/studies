kompilator asemblera w pythonie generujący kod binarny do uruchomienia na maszynie wirtualnej

dane
	rodzaje dostępu do danych
		istnieją 4 rodzaje dostępu do danych:
			B - BYTE(8bit)
			W - WORD(16bit)
			D - DWORD(32bit)
			Q - QWORD(64bit)
	wszystkie dane są signed

pamięć
	pamięć jest adresowana od 0, jej rozmiar musi być wielokrotnością BYTE(8bit), little endian bitwise

rejestry
	istnieje 8 rejestrów ogólnego przeznaczenia: a, b, c, d, e, f, g, h. Każdy z nich ma rozmiar QWORD

stos
	przechowuje wartości o rozmiarze DWORD

opis instrukcji
	cpy - kopiowanie wartości
	add - dodawanie
	sub - odejmowanie
	mul - mnozenie
	div - dzielenie calkowite
	and - bramka and na bitach
	lor - bramka or na bitach
	not - bramka not na bitach
	xor - bramka xor na bitach
	psh - push na stos
	pop - pop ze stosu
	cmp - porownanie
	jmp - skok w określone miejsce
	jeq - jump equal skok warunkowy
	jne - jump not equal skok warunkowy
	out - wypisywanie danych na output
	cal - wołanie instrukcji z danego adresu
	ret - ret powrót
	reg - zarejestrowanie danych do późniejszego wykonania
	exe - wykonanie zarejestrowanych wcześniej danych

argumenty instrukcji - isstnieją 3 typy argumentów
	-[R] wartość rejestru - musi być podana labelka rejestru(a-h)
	-[C] stała - wymagana wartość, zawsze 64bit
	-[M] dane z pamięci - muszą być podane rodzaj dostępu oraz adres

zapis argumentów - argumenty są zapisywane jako "TYP:wartość1,wartość2", gdzie typ to R(rejestr), C(stała) lub M(dane z pamięci). Są oddzielone średnikami. Przykład:
	cpy([M] D, 234; [R]: a)

specyfikacja instrukcji
	cpy([R/C/M] from; [R] to) - kopiuje wartość z from do to
	add([R/C/M] x; [R/C/M] y; [R] res) - res = x + y
	sub([R/C/M] x; [R/C/M] y; [R] res) - res = x - y
	mul([R/C/M] x; [R/C/M] y; [R] res) - res = x * y
	div([R/C/M] x; [R/C/M] y; [R] res) - res = x / y
	and([R/C/M] x; [R/C/M] y; [R] res) - res = x & y
	lor([R/C/M] x; [R/C/M] y; [R] res) - res = x | y
	not([R/C/M] x; [R] res) - res = !x
	xor([R/C/M] x; [R/C/M] y; [R] res) - res = x ^ y
	psh([R/C/M] x) - push x to the stack
	pop([R] x) - pop from stack and insert into x
	cmp([R/C/M] x; [R/C/M] y; [R] res) - res = (x > y) => 1, (x < y) => -1, (x == y) => 0
	jmp([R/C/M] addr) - jump to address from addr
	jeq([R/C/M] x; [R/C/M] y; [R/C/M] addr) - jump to addr if x == y
	jne([R/C/M] x; [R/C/M] y; [R/C/M] addr) - jump to addr if x != y
	out([R/C/M] data) - writes data to standard output
	cal([R/C/M] addr) - push next function address to the stack and jump to addr
	ret() - pop return address from the stack and jump there
	reg([R/C/M] data) - stores data in memory buffer for further execute
	exe([R/C] result) - executes data from buffer as system command, stores result code in result

syntax:
	- kazda instrukcja ma labelke o dlugosci 3 znaki ASCII
	- po labelce instrukcji są wczytywane argumenty w nawiasach oddzielone średnikami: typ nawiasu w [] oraz wartość
	- instrukcje sa oddzielone srednikami ;
	- komentarze zaczynają się od specjalnego znaku: # oraz kończą się, tak jak instrukcje, średnikiem ;
	- syntax nie bierze pod uwage spacji, endl, tabow itp
	przyklad:
		add([R]r0,[C]1,[R]r2); sub([C]400,[R]r2,[R]r0);#here is the comment where I say how this works ; cmp([R] r0, [C] 123, [R] r2)

-parsowanie kodu asm
-generowanie bytecodu
-testy

1. kompilacja
	- skaner - analiza leksykalna - wyodrębnia tokeny i usuwa niepotrzebne znaki(spacje, komentarze itp)
	- parser - analiza składniowa - buduje drzewo składniowe
	- generator - przekład kodu asm na kod binarny według podanych wytycznych
