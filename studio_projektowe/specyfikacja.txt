kompilator asemblera w pythonie generujący kod binarny do uruchomienia na maszynie wirtualnej

dane
	rodzaje dostępu do danych
		istnieją 4 rodzaje dostępu do danych:
			byt - BYTE(8bit)
			wrd - WORD(16bit)
			dwd - DWORD(32bit)
			qwd - QWORD(64bit)
	wszystkie dane są signed

pamięć
	pamięć jest adresowana od 0, jej rozmiar musi być wielokrotnością BYTE(8bit), little endian bitwise

rejestry
	istnieje 8 rejestrów ogólnego przeznaczenia: r0, r1, r2, r3, r4, r5, r6, r7. Każdy z nich ma rozmiar QWORD

stos
	przechowuje wartości o rozmiarze DWORD

opis instrukcji
	cpy - kopiowanie wartości
	add - dodawanie
	sub - odejmowanie
	mul - mnozenie
	div - dzielenie calkowite
	and - bramka and na bitach
	lor - bramka or na bitach
	not - bramka not na bitach
	xor - bramka xor na bitach
	psh - push na stos
	pop - pop ze stosu
	cmp - porownanie
	jmp - skok w określone miejsce
	jeq - jump equal skok warunkowy
	jne - jump not equal skok warunkowy
	out - wypisywanie danych na output
	cal - wołanie instrukcji z danego adresu
	ret - ret powrót
	reg - zarejestrowanie danych do późniejszego wykonania
	exe - wykonanie zarejestrowanych wcześniej danych

argumenty instrukcji - isstnieją 3 typy argumentów
	-[reg] wartość rejestru - musi być podana labelka rejestru(a-h)
	-[con] stała - wymagana wartość, zawsze 64bit
	-[mem] dane z pamięci - muszą być podane rodzaj dostępu oraz adres

zapis argumentów - argumenty są zapisywane jako "TYP:wartość1;wartość2", gdzie typ to reg(rejestr), con(stała) lub mem(dane z pamięci). Są oddzielone średnikami. Przykład:
	cpy([mem] dwd, 234; [reg]: r0)

specyfikacja instrukcji
	cpy([reg/con/mem] from; [reg] to) - kopiuje wartość z from do to
	add([reg/con/mem] x; [reg/con/mem] y; [reg] res) - res = x + y
	sub([reg/con/mem] x; [reg/con/mem] y; [reg] res) - res = x - y
	mul([reg/con/mem] x; [reg/con/mem] y; [reg] res) - res = x * y
	div([reg/con/mem] x; [reg/con/mem] y; [reg] res) - res = x / y
	and([reg/con/mem] x; [reg/con/mem] y; [reg] res) - res = x & y
	lor([reg/con/mem] x; [reg/con/mem] y; [reg] res) - res = x | y
	not([reg/con/mem] x; [reg] res) - res = !x
	xor([reg/con/mem] x; [reg/con/mem] y; [reg] res) - res = x ^ y
	psh([reg/con/mem] x) - push x to the stack
	pop([reg] x) - pop from stack and insert into x
	cmp([reg/con/mem] x; [reg/con/mem] y; [reg] res) - res = (x > y) => 1, (x < y) => -1, (x == y) => 0
	jmp([reg/con/mem] addr) - jump to address from addr
	jeq([reg/con/mem] x; [reg/con/mem] y; [reg/con/mem] addr) - jump to addr if x == y
	jne([reg/con/mem] x; [reg/con/mem] y; [reg/con/mem] addr) - jump to addr if x != y
	out([reg/con/mem] data) - writes data to standard output
	cal([reg/con/mem] addr) - push next function address to the stack and jump to addr
	ret() - pop return address from the stack and jump there
	reg([reg/con/mem] data) - stores data in memory buffer for further execute
	exe([reg/con] result) - executes data from buffer as system command, stores result code in result

syntax:
	- kazda instrukcja ma labelke o dlugosci 3 znaki ASCII
	- po labelce instrukcji są wczytywane argumenty w nawiasach oddzielone średnikami: typ nawiasu w [] oraz wartość
	- instrukcje sa oddzielone srednikami ;
	- komentarze zaczynają się od specjalnego znaku: # oraz kończą się, tak jak instrukcje, średnikiem ;
	- syntax nie bierze pod uwage spacji, endl, tabow itp
	przyklad:
		add([reg]r0;[C]1;[reg]r1); sub([C]400;[reg]r1;[reg]r0);#here is the comment where I say how this works ; cmp([reg] r0; [C] 123; [reg] r1)

-parsowanie kodu asm
-generowanie bytecodu
-testy

1. kompilacja
	- skaner - analiza leksykalna - wyodrębnia tokeny i usuwa niepotrzebne znaki(spacje, komentarze itp)
	- parser - analiza składniowa - buduje drzewo składniowe
	- generator - przekład kodu asm na kod binarny według podanych wytycznych

1.1 gramatyka

terminals = 'cpy','add','sub','mul','div','and','lor','not','xor','psh','pop','cmp','jmp','jeq','jne','out','cal','ret','reg','exe',';',',','(',')','[',']','0','1','2','3','4','5','6','7','8','9','r0','r1','r2','r3','r4','r5','r6','r7','byt','wrd','dwd','qwd','reg','con','mem'
nonterminals = 
	'S',	start symbol
	'I',	instruction
	'A',	argument
	'R',	register label
	'N',	number
	'M',	memory access type
start_symbol = 'S'
productions

S -> IS | I
I ->
	cpy(A;A); |
	add(A;A;A); |
	sub(A;A;A); |
	mul(A;A;A); |
	div(A;A;A); |
	and(A;A;A); |
	lor(A;A;A); |
	not(A;A); |
	xor(A;A;A); |
	psh(A); |
	pop(A); |
	cmp(A;A;A); |
	jmp(A); |
	jeq(A;A;A); |
	jne(A;A;A); |
	out(A); |
	cal(A); |
	ret(); |
	reg(A); |
	exe(A);
A -> [reg] R | [con] N | [mem] M, N
R -> r0 | r1 | r2 | r3 | r4 | r5 | r6 | r7
N -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | NN
M -> byt | wrd | dwd | qwd
